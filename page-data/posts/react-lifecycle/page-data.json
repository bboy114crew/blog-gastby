{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/react-lifecycle/","result":{"data":{"markdownRemark":{"id":"d926e790-39c2-51c1-bb77-d5b408c82b21","html":"<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">→  render → reconciliation → commit\n         ↖                   ↙\n              state change</code></pre></div>\n<p>Let’s define a few terms:</p>\n<ul>\n<li>The “render” phase: create React elements React.createElement</li>\n<li>The “reconciliation” phase: compare previous elements with the new ones</li>\n<li>The “commit” phase: update the DOM (if needed).</li>\n</ul>\n<p>React exists in its current form (in large part) because updating the DOM is the\nslowest part of this process. By separating us from the DOM, React can perform\nthe most surgically optimal updates to the DOM to speed things up for us\nbig-time.</p>\n<p>A React Component can re-render for any of the following reasons:</p>\n<ol>\n<li>Its props change</li>\n<li>Its internal state changes</li>\n<li>It is consuming context values which have changed</li>\n<li>Its parent re-renders</li>\n</ol>\n<p>React is really fast, however, <em>sometimes</em> it can be useful to give React little\ntips about certain parts of the React tree when there’s a state update. You can\nopt-out of state updates for a part of the React tree by using one of React’s\nbuilt-in rendering bail-out utilities: <code class=\"language-text\">React.PureComponent</code>, <code class=\"language-text\">React.memo</code>, or\n<code class=\"language-text\">shouldComponentUpdate</code>.</p>","fields":{"slug":"/posts/react-lifecycle/","tagSlugs":["/tag/note/"]},"frontmatter":{"date":"2021-05-05","description":"React Explained 101.","tags":["Note"],"title":"React Lifecycle","socialImage":null}}},"pageContext":{"slug":"/posts/react-lifecycle/"}},"staticQueryHashes":["251939775","3691206191","401334301"]}